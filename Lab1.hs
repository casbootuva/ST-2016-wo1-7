module Lab1 where
import Data.List
import Data.Bits
import Test.QuickCheck    

prime :: Integer -> Bool
prime n = n > 1 && all (\ x -> rem n x /= 0) xs
  where xs = takeWhile (\ y -> y^2 <= n) primes

primes :: [Integer]
primes = 2 : filter prime [3..] 

nPrimes :: Integer -> [Integer]
nPrimes n = 2 : filter prime [3..n]

infix 1 --> 

(-->) :: Bool -> Bool -> Bool
p --> q = (not p) || q

forall :: [a] -> (a -> Bool) -> Bool
forall = flip all

reversal :: Integer -> Integer
reversal = read . reverse . show

-- For assignment 1, 2 and 3 the following notes:
-- This way of testing (using sequences) does not only test the formula used in the sequence,  
-- but also the construction of the sequence (i.e. the list comprehension and map, sum etc.)
-- The result of using the sequences in combination with QuickCheck is that not only
-- the input values (k) generated by QuickCheck will be tested, but all values between 0 and k.
-- Negative values are not tested, since the list comprehension will work from 0 upwards.

-- 1h
-- 1.
-- Redo exercises 2 and 3 of Workshop 1 by writing QuickCheck tests for these statements. 
-- See the end of Lecture 1 for how this can be done.

-- Exercise 2
e2seq1 k = map sum [ map (^2) [1..n] | n <- [0..k] ]
e2seq2 k = map (\ n -> ((n * (n+1) * (2*n + 1)) `div` 6)) [0..k]

e2Test = \ n -> e2seq1 n == e2seq2 n

-- Exercise 3
e3seq1 k = map sum [ map (^3) [1..n] | n <- [0..k] ]
e3seq2 k = map (\ n -> ((n * (n+1)) `div` 2)^2) [0..k]

e3Test = \ n -> e3seq1 n == e3seq2 n 

-- 1h
-- 2. Redo exercise 4 of Workshop 1 by replacing sets by lists, and testing the property for 
--    integer lists of the form [1..n]. 
--    You can use subsequences :: [a] -> [[a]] for the list of all subsequences of a given list.

-- Yes, this property is 'hard' to test using QuickCheck in a sence that it will take too much time. 
-- The size of the powerset increases exponentially, and so does the time required to build the list
-- and count the number of elements in the list.
-- Time required for 'subsequences [1..12]' is ~7s. 
-- Time required for 'subsequences [1..50]' would be:
-- 7*2^(50-12) = 7*2^38 ~= 2 * 10^12 seconds ~= 62556 year.  

-- This test does check the mathematical fact that the number of subsequences of a list with n elemenets
-- equals 2^n. It does not check the induction that we used to prove this fact during the workshop.
-- It does not test the correctness of the subsequences generated by the function subsequences, it only tests
-- whether the number of generated subsequences is correct.
-- In this case the functions map, length and the list comprehension are tested.
e4seq1 k = map length [ subsequences [1..n] | n <- [0..k] ]
e4seq2 k = [ 2^n | n <- [0..k] ]

e4Test = \n -> e4seq1 n == e4seq2 n

-- 3. Redo exercise 5 of Workshop 1 by replacing sets by lists, 
--    and testing the property for integer lists of the form [1..n].

-- Yes, this property is 'hard' to test using QuickCheck in a sence that it will take too much time. 
-- The number of permutations increases exponentially, and so does the time required to build the list
-- and count the number of elements in the list.
-- The number of permutations increases more than the number of subsequences, since subsequences are combinations.

e5seq1 k = map length [permutations [1..n] | n <- [0..k] ]
e5seq2 k = map product [ [1..n] | n <- [0..k] ]

e5Test = \n -> e5seq1 n == e5seq2 n


-- 4. The natural number 13 has the property that it is prime and its reversal, 
--    the number 31, is also prime. 
--    Write a function that finds all primes < 10000 with this property.
revPrimes :: [Integer]
revPrimes = filter revPrime xs
       where xs = takeWhile (< 10000) primes

revPrime :: Integer -> Bool
revPrime n =  prime n && prime (reversal n)

-- 5. The number 101 is a prime, and it is also the sum of five consecutive primes, 
--    namely 13+17+19+23+29. Find the smallest prime number that is a sum of 101 consecutive primes.
--    Do you have to test that your answer is correct? How could this be checked?

consecPrimesn :: (Integer, [Integer])
consecPrimesn = consecPrimes 101 primes
              
consecPrimes :: Int -> [Integer] -> (Integer, [Integer])
consecPrimes n (x:xs) | prime (sum nConsecPrimes) = (sum nConsecPrimes, nConsecPrimes)
                      | otherwise                 = consecPrimes n (xs)
                      where nConsecPrimes = take n (x:xs)
                       
-- You can test whether the sum of the consecutive primes is a prime, and whether all
-- the consecutive primes really are consecutive primes. In this case this does not have to be tested,
-- because consecPrimes only uses primes, and will always use a list of consecutive primes.
-- This is done by 'take n (x:xs)' where (x:xs) will always be an (infenite) list of consecutive primes.


-- 6. Using Haskell to refute a conjecture. 
--    Write a Haskell function that can be used to refute the following conjecture. 
--    "If p1...pn is a list of consecutive primes starting from 2, 
--    then (p1 * ... * pn)+1 is also prime." 
--    This can be refuted by means of a counterexample, so your Haskell program should 
--    generate counterexamples. What is the smallest counterexample?

refuteConject :: (Integer, [Integer])
refuteConject = refuteConject' 2

-- [2,3] -> [2,3,5] -> [2,3,5,7]
refuteConject' :: Int -> (Integer, [Integer])
refuteConject' n | prime conjectResult           = refuteConject' (n+1)
                 | otherwise                     = (conjectResult, primeList)
                 where primeList     = take n primes
                       conjectResult = product primeList + 1

-- 7. Implement and test the Luhn Algorithm
--    The Luhn algorithm is a formula for validating credit card numbers.
--    1. from the right most digit (excluding it), double every digit.
--       If it is greater than 9, subtract 9.
--    2. Take the sum of all digits.
--    3. Modulo 10 should equal 0.

-- 79927398713

luhn :: Integer -> Bool
luhn n = luhnChecksum n `mod` 10 == 0

-- Read from right to left.
-- 1. reverse n
-- 2. convert to list of digits
-- 3. double every 2nd digit in the list
-- 4. Wrap around every digit in the list (if >9, subtract 9)
-- 5. Sum all integers in the list. This will be the checksum, modulo 10 should == 0.
luhnChecksum :: Integer -> Integer
luhnChecksum n = sum $ map luhnWrap $ double $ digits $ reversal n
              
double :: [Integer] -> [Integer]        
double = zipWith (*) $ cycle [1,2]

luhnWrap :: Integer -> Integer
luhnWrap n | n > 9     = n - 9
           | otherwise = n
             
digits :: Integer -> [Integer]
digits n = map (\x -> read [x] :: Integer) (show n)

prefixOfAny :: Integer -> [Integer] -> Bool
prefixOfAny x = any (\n -> prefixOf n x)

prefixOf :: Integer -> Integer -> Bool
prefixOf x y = (digits x) `isPrefixOf` (digits y)

-- Length should be at least 7 digits (IIN plus check digit)
-- And luhn check should pass.
isCreditCard :: Integer -> Bool
isCreditCard n = length (digits n) >=7 && luhn n

-- According to internet sources, the length of any of the
-- CreditCard types can change at any time. So we cannot check anything
-- other than length <= 7..

-- MasterCard starts with 51-55, 222100-272099
isMaster :: Integer -> Bool
isMaster n = isCreditCard n && prefixOfAny n ([51..55] ++ [222100..272099])

-- American Express starts with 34 or 37
isAmericanExpress :: Integer -> Bool
isAmericanExpress n = isCreditCard n && prefixOfAny n [34,37]

-- Visa starts with 4
isVisa :: Integer -> Bool
isVisa n = isCreditCard n && prefixOfAny n [4]

luhnTestTrue = map luhn [49927398716, 1234567812345670]
luhnTestFalse = map luhn [49927398717, 1234567812345678]

isAmericanExpressTestTrue = map isAmericanExpress [371449635398431, 371449635398432]
isAmericanExpressTestFalse = map isAmericanExpress [4716104985179222, 5555555555554444]

isMasterTestFalse = map isMaster [371449635398431, 347349224140247]
isMasterTestTrue = map isMaster [5555555555554444, 5055555555554444]

isVisaTestFalse = map isVisa [371449635398431, 347349224140247]
isVisaTestTrue = map isVisa [4916261822922814, 5916261822922814]
                      

{-|  8. Crime Scene Investigation
 A group of five school children is caught in a crime. 
 One of them has stolen something from some kid they all dislike. 
 The headmistress has to find out who did it. She questions the children, 
 and this is what they say:

 Matthew: Carl didn't do it, and neither did I.
 Peter: It was Matthew or it was Jack.
 Jack: Matthew and Peter are both lying.
 Arnold: Matthew or Peter is speaking the truth, but not both.
 Carl: What Arnold says is not true.
 
 Their class teacher now comes in. She says: 
 three of these boys always tell the truth, and two always lie. 
 You can assume that what the class teacher says is true. 
 
 Use Haskell to write a function that computes who was the thief, 
 and a function that computes which boys made honest declarations.
-}

data Boy = Matthew | Peter | Jack | Arnold | Carl 
           deriving (Eq,Show)

boys = [Matthew, Peter, Jack, Arnold, Carl]

-- whether a boy accuses another boy.
accuses :: Boy -> Boy -> Bool
accuses accuser accusee 
            | accuser == Matthew = not (accusee `elem` [Carl,Matthew])
            | accuser == Peter   = accusee `elem` [Jack,Matthew]
            | accuser == Jack    = not (accuses Matthew accusee) && not(accuses Peter accusee)
            | accuser == Arnold  = accuses Matthew accusee `xor` accuses Peter accusee
            | accuser == Carl    = not (accuses Arnold accusee)
            | otherwise = False

-- list of accusers of each boy
accusers :: Boy -> [Boy]
accusers boy = filter (flip accuses boy) boys

-- list of guilty boys
guilty :: [Boy]
guilty = [boy | boy <- boys, length (accusers boy) == 3]

-- list of boys who made honest (true) statements.
honest :: [Boy]
honest = head [accusers boy | boy <- boys, length (accusers boy) == 3]



--Bonus Exercises --Project Euler

-- 9.
-- A Pythagorean triplet is a set of three natural numbers, a < b < c, for which,
-- a^2 + b^2 = c^2
-- For example, 3^2 + 4^2 = 9 + 16 = 25 = 5^2.

-- There exists exactly one Pythagorean triplet for which a + b + c = 1000.
-- Find the product abc.

pythagoreanTriplet :: (Integer,(Integer,Integer,Integer))
pythagoreanTriplet = head [(a*b*c, (a,b,c)) |c <- [1..], b <- [1..c], a <- [1..b], a^2 + b^2 == c^2, a + b + c == 1000]

-- 10.
-- The sum of the primes below 10 is 2 + 3 + 5 + 7 = 17.
-- Find the sum of all the primes below two million.

primeSumBelowX :: Integer -> Integer
primeSumBelowX x = sum $ nPrimes x

solutionE10 = primeSumBelowX 2000000

-- 49.
-- The arithmetic sequence, 1487, 4817, 8147, in which each of the terms increases by 3330, 
-- is unusual in two ways: (i) each of the three terms are prime, 
-- and, (ii) each of the 4-digit numbers are permutations of one another.

-- There are no arithmetic sequences made up of three 1-, 2-, or 3-digit primes, 
-- exhibiting this property, but there is one other 4-digit increasing sequence.

-- What 12-digit number do you form by concatenating the three terms in this sequence?
specialPrimeSeq :: [[Integer]]
specialPrimeSeq =  filter (\ (x:y:z:_) -> (z - y == y - x)
                          && ((sort $ show z) == (sort $ show y))
                          && ((sort $ show z) == (sort $ show x))) quartetDigitsPrime

fourDigitsPrime :: [Integer]
fourDigitsPrime = filter prime [1000..9999] 

quartetDigitsPrime :: [[Integer]]
quartetDigitsPrime = filter (\x -> length x == 3) (subsequences $ fourDigitsPrime)


